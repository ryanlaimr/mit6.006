'''Implementation of AVL Tree and AVL Sort in Python.AVL trees require heights of left and right children of every node to differ by at most 1.Namely |h_left - h_right| <= 1AVL trees are always balanced. (Height is always log(n).)'''class Node:    def __init__(self, key):        self.key = key        self.left = None        self.right = None        self.height = 1class AVLTree:    def __init__(self):        self.root = None    def insert(self, key):        self.root = self._insert(self.root, key)    def _insert(self, root, key):        if not root:            return Node(key)        elif key < root.key:            root.left = self._insert(root.left, key)        else:            root.right = self._insert(root.right, key)        root.height = 1 + max(self._get_height(root.left), self._get_height(root.right))        balance_factor = self._get_balance_factor(root)        if balance_factor > 1:            if key < root.left.key:                return self._rotate_right(root)            else:                root.left = self._rotate_left(root.left)                return self._rotate_right(root)        elif balance_factor < -1:            if key > root.right.key:                return self._rotate_left(root)            else:                root.right = self._rotate_right(root.right)                return self._rotate_left(root)        return root    def _get_height(self, root):        if not root:            return 0        return root.height    def _get_balance_factor(self, root):        if not root:            return 0        return self._get_height(root.left) - self._get_height(root.right)    def _rotate_left(self, z):        y = z.right        T2 = y.left        y.left = z        z.right = T2        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))        return y    def _rotate_right(self, z):        y = z.left        T3 = y.right        y.right = z        z.left = T3        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))        return y    def inorder_traversal(self):        self._inorder_traversal(self.root)    def _inorder_traversal(self, root):        if root:            self._inorder_traversal(root.left)            print(root.key, end=" ")            self._inorder_traversal(root.right)'''Test the AVL Tree'''import unittestclass TestAVLTree(unittest.TestCase):    def test_insert(self):        avl_tree = AVLTree()        avl_tree.insert(10)        avl_tree.insert(20)        avl_tree.insert(30)        avl_tree.insert(40)        avl_tree.insert(50)        avl_tree.insert(25)        # Check if the tree is balanced        self.assertEqual(avl_tree.root.key, 30)        self.assertEqual(avl_tree.root.left.key, 20)        self.assertEqual(avl_tree.root.right.key, 40)        self.assertEqual(avl_tree.root.left.left.key, 10)        self.assertEqual(avl_tree.root.left.right.key, 25)        self.assertEqual(avl_tree.root.right.right.key, 50)    def test_inorder_traversal(self):        avl_tree = AVLTree()        avl_tree.insert(10)        avl_tree.insert(20)        avl_tree.insert(30)        avl_tree.insert(40)        avl_tree.insert(50)        avl_tree.insert(25)        # Check if the inorder traversal is correct        expected_output = "10 20 25 30 40 50 "        import sys        from io import StringIO        captured_output = StringIO()        sys.stdout = captured_output        avl_tree.inorder_traversal()        sys.stdout = sys.__stdout__        self.assertEqual(captured_output.getvalue(), expected_output)if __name__ == '__main__':    unittest.main()